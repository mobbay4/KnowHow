{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Foreword This is a Repository for knowledge sharing. The Idea is to document solutions for Problems one had to solve.","title":"Foreword"},{"location":"index.html#foreword","text":"This is a Repository for knowledge sharing. The Idea is to document solutions for Problems one had to solve.","title":"Foreword"},{"location":"UNIT_Tests/python.html","text":"UNIT tests in Python First of all, there is a folder test in parallel to the source-code folder of the Python package, containing all testing files. In this folder, we add a README.md file explaining how the tests are structured. test-functions AssertEqual-function : compare a return value of a function/class with a expected value If we test only on exceptions: Assert(True) If we want to test on a special exception, we use assertions about expected exceptions `setup function: To prepare for the tests, for example, provide access to a database. The setup function runs at first. TearDown-function : Diminish the test resources after the tests, for example, to cut the connection to a database. Call of tests We call tests via the command line. Thereby we can select which tests should run and also skip tests. Later is helpful if the package is not developed enough to execute a particular test. Test results The results are presented in a JUnitXML -file, which can be opened in a browser window. Thereof we get a graphical response about the test results. How to organize the expected values of the tests Parameterization of test-functions For n test values (e.g., by a limiter), it makes sense to parameterize the test functions. The test cases can be created in the test modules or separate parameter files. Parameterization has the advantage that it is immediately visible which test has failed in case of an error. Usage of test-classes Test classes are mainly for test organization. Therefore one understands, which test functions are connected since they are collected in one class. Test types Limit-tests: Execute value below lower border and above upper border as test sign-test Testing in Python The absolute standard package is the Pytest -package. Pytest contains the following components: there is a test folder there is a test runner Conftest.py configures the tests Pytest fixture (deocrator) : Test preparation and clean up for code Test-files : module names all have the prefix test in their filenames Test-functions : Function-names also have the prefix test . The rest of the name should be as descriptive as possible. tests can be parameterized Test coverage One can use tools like Codecov to measure the test-coverage of your code. It runs through all your source code files and checks which lines are covered by the tests you have written so far. Thereoff you can detect potential weaknesses in your code. To learn more one can have a look at this more general but excelent tutorial","title":"Unit Testing"},{"location":"UNIT_Tests/python.html#unit-tests-in-python","text":"First of all, there is a folder test in parallel to the source-code folder of the Python package, containing all testing files. In this folder, we add a README.md file explaining how the tests are structured.","title":"UNIT tests in Python"},{"location":"UNIT_Tests/python.html#test-functions","text":"AssertEqual-function : compare a return value of a function/class with a expected value If we test only on exceptions: Assert(True) If we want to test on a special exception, we use assertions about expected exceptions `setup function: To prepare for the tests, for example, provide access to a database. The setup function runs at first. TearDown-function : Diminish the test resources after the tests, for example, to cut the connection to a database.","title":"test-functions"},{"location":"UNIT_Tests/python.html#call-of-tests","text":"We call tests via the command line. Thereby we can select which tests should run and also skip tests. Later is helpful if the package is not developed enough to execute a particular test.","title":"Call of tests"},{"location":"UNIT_Tests/python.html#test-results","text":"The results are presented in a JUnitXML -file, which can be opened in a browser window. Thereof we get a graphical response about the test results.","title":"Test results"},{"location":"UNIT_Tests/python.html#how-to-organize-the-expected-values-of-the-tests","text":"","title":"How to organize the expected values of the tests"},{"location":"UNIT_Tests/python.html#parameterization-of-test-functions","text":"For n test values (e.g., by a limiter), it makes sense to parameterize the test functions. The test cases can be created in the test modules or separate parameter files. Parameterization has the advantage that it is immediately visible which test has failed in case of an error.","title":"Parameterization of test-functions"},{"location":"UNIT_Tests/python.html#usage-of-test-classes","text":"Test classes are mainly for test organization. Therefore one understands, which test functions are connected since they are collected in one class.","title":"Usage of test-classes"},{"location":"UNIT_Tests/python.html#test-types","text":"Limit-tests: Execute value below lower border and above upper border as test sign-test","title":"Test types"},{"location":"UNIT_Tests/python.html#testing-in-python","text":"The absolute standard package is the Pytest -package. Pytest contains the following components: there is a test folder there is a test runner Conftest.py configures the tests Pytest fixture (deocrator) : Test preparation and clean up for code Test-files : module names all have the prefix test in their filenames Test-functions : Function-names also have the prefix test . The rest of the name should be as descriptive as possible. tests can be parameterized","title":"Testing in Python"},{"location":"UNIT_Tests/python.html#test-coverage","text":"One can use tools like Codecov to measure the test-coverage of your code. It runs through all your source code files and checks which lines are covered by the tests you have written so far. Thereoff you can detect potential weaknesses in your code. To learn more one can have a look at this more general but excelent tutorial","title":"Test coverage"},{"location":"annex/getting_started.html","text":"Getting Started The following explains how to set up the local environment to write and deploy the documentation. Environment Setup First of all we need to clone the repository structure locally. For the moment it is intendet to have following local folder structure: !!! - Know_How - master # contains clone of master branch - gh-pages # contains clone of gh-pages branch We want to folders for the two branches since if we want to deploy our documentation on GitLab we need to build it locally and push it to the gh-pages branch. The documentation deployment is explained in the next section. So to introduce this local environment we perform following steps: create a folder Know_How in latter folder clone the repository twice and rename cloned folders to master and gh-pages then move into the gh-pages folder execute the command $ git checkout gh-pages for switching to the right branch Now we move to the master folder execute pip install virtualenv create an virtual environment with $ virtualenv venv (may $ python -m virtualenv venv ) activate the environment with $ source venv/bin/activate install the requirements with $ pip install -r requirements.txt configure the git hooks with $ pre-commit install Now the basic setup is done. The git-hooks are executed before every commit in the master branch. So it is recommended to commit bofore deploying the documentation. One can apply the git-hooks on all repository files with: $ pre-commit run --all-files Deploy the Documentation To deploy the documentation we need to build and push the static html to the gh-pages branch. With above described setup this process is (at least a bit simlified) by the deploy.sh script. Just move to the gh-pages folder and execute bash deploy.sh . This automatically builds, moves, pushes the documentation to the correct branch. Add Content to the Documentation The add content one has to modify the files in the /docs folder in the master branch. Just add to existing files or create new ones add your content. To add new files one has to additionally adjust the nav section in the mkdocs.yml file.","title":"Getting Started"},{"location":"annex/getting_started.html#getting-started","text":"The following explains how to set up the local environment to write and deploy the documentation.","title":"Getting Started"},{"location":"annex/getting_started.html#environment-setup","text":"First of all we need to clone the repository structure locally. For the moment it is intendet to have following local folder structure: !!! - Know_How - master # contains clone of master branch - gh-pages # contains clone of gh-pages branch We want to folders for the two branches since if we want to deploy our documentation on GitLab we need to build it locally and push it to the gh-pages branch. The documentation deployment is explained in the next section. So to introduce this local environment we perform following steps: create a folder Know_How in latter folder clone the repository twice and rename cloned folders to master and gh-pages then move into the gh-pages folder execute the command $ git checkout gh-pages for switching to the right branch Now we move to the master folder execute pip install virtualenv create an virtual environment with $ virtualenv venv (may $ python -m virtualenv venv ) activate the environment with $ source venv/bin/activate install the requirements with $ pip install -r requirements.txt configure the git hooks with $ pre-commit install Now the basic setup is done. The git-hooks are executed before every commit in the master branch. So it is recommended to commit bofore deploying the documentation. One can apply the git-hooks on all repository files with: $ pre-commit run --all-files","title":"Environment Setup"},{"location":"annex/getting_started.html#deploy-the-documentation","text":"To deploy the documentation we need to build and push the static html to the gh-pages branch. With above described setup this process is (at least a bit simlified) by the deploy.sh script. Just move to the gh-pages folder and execute bash deploy.sh . This automatically builds, moves, pushes the documentation to the correct branch.","title":"Deploy the Documentation"},{"location":"annex/getting_started.html#add-content-to-the-documentation","text":"The add content one has to modify the files in the /docs folder in the master branch. Just add to existing files or create new ones add your content. To add new files one has to additionally adjust the nav section in the mkdocs.yml file.","title":"Add Content to the Documentation"},{"location":"annex/how_to_contribute.html","text":"How to Contribute This section explains how to contribute shit to this knowledge collection. First, you should set up a local environment as explained in the getting started . After this, you can add any tutorials, link collections, or explanations you find helpful. :)","title":"How to Contribute"},{"location":"annex/how_to_contribute.html#how-to-contribute","text":"This section explains how to contribute shit to this knowledge collection. First, you should set up a local environment as explained in the getting started . After this, you can add any tutorials, link collections, or explanations you find helpful. :)","title":"How to Contribute"}]}